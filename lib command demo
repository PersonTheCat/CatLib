

    // Example of a command being registered to the library.
    // Note that a help command will be generated in this
    // format: `/modid help <idx|name>`
    public static void registerModCommands() {
        // The mod descriptor contains a name, id, and config folder.
        CommandRegistrationContext.forMod(MOD_DESCRIPTOR)
            
            // Add any number of sub commands. These will be
            // registered in the format `/modid cmd ...`
            .addSubCommand(DEMO_COMMAND)
            
            // Add any number of global commands. These will
            // be registered in the format `/cmd ...`
            .addGlobalCommand(GLOBAL_COMMAND)
            
            // Add all of the default commands provided by
            // the library.
            .addLibCommands()
            
            // Finally, register every command in the context.
            .registerAll();
    }


	// In a class called "ModCommands"
	private static final LibCommandBuilder DEMO_COMMAND = LibCommandBuilder.name("demo")
	    
	    // Describe the arguments needed
		.arguments("<basic|full> [<any>]")
		
		// Provide a short description for the help screen
		.description("Runs the demo command.")
		
		// Optionally wrap an execution endpoint
		.wrap(BASIC_DEMO, ModCommands::basicDemo)
		
		// Wrap any number of execution endpoints
		.wrap(FULL_DEMO, ModCommands::fullDemo)
		
		// Optionally add a custom syntax linter. This
        // will be exposed by the command context wrapper
        .linter(CUSTOM_LINTER)
		
		// Generate the underlying LiteralArgumentBuilder
		.generate((builder, wrappers) -> builder
		
		    // Generate a regular Brigadier argument tree
		    .then(literal("basic")
			    .executes(wrappers.get(BASIC_DEMO)))
			.then(literal("full)
			    .executes(wrappers.get(FULL_DEMO)))
		);


    // Example execution endpoint for `/<modid> demo basic`
    private static void basicDemo(final CommandContextWrapper wrapper) {
        // Demonstrates that the wrapper provides additional
        // utilities on top of the standard command context.
        final Optional<String> arg = wrapper.getOptional("arg", String.class);
        if (!arg.isPresent() {
            // The wrapper prefers exceptions over returning -1
            throw new CommandExecutionException("No argument provided!");
        }
        // The wrapper has built in support for list args.
        final List<String> listArg = wrapper.getList("list", String.class);
        
        // The wrapper has convenience methods to send messages
        wrapper.sendMessage("", ...); // Can optionally interpolate
        wrapper.sendError("", ...); // Conveniently send error messages
        
        // No need to return the status.
    }
    
   // In the future: 
   @GlobalCommand( // or @ModCommand
        name = "update",
        arguments = "<file> [<path>] [<value>]",
        description = {
            "Manually update a JSON value. Omit the value or",
            "path to display the current contents"
        },
        branch = {
            @Node(key = "file", type = HjsonArgument.Result.class, executes = false),
            @Node(key = "path", type = PathArgument.Result.class)
        }
    )
    
This is the first line of text. The actual concatenated 
lines do not matter. These lines will be cut down to 
the expected length and wrapped. Any text that extends 
beyond the current line will be pushed onto the next 
line. Just as an example, this text will continue in 
the concatenated string literals for a couple more 
lines.



   Default lib commands:
   
     * /<mod> help
     * /<mod> update
     * /<mod> display
     * /<mod> backup
     * /<mod> copy
     * /<mod> move
     * /<mod> delete
     * /<mod> clean
     * /<mod> rename
     * /<mod> open
     
     * /<mod> combine

















